# 단일 책임 원칙 Single Responsibility Principle
첫번쨰 원칙인 SRP 이다.  
전체적으로 모든 부분을 적으면 비효율적일 것 같아 글에서 중요하다고 느낀 키워드와 그 키워드에 대해 정리한 글을 쓰려한다.  
🐗 즉 멧돼지의 시선에서 본 SRP이다.  

블로그글과 책을 모두 읽고 작성한 내용으로 두개가 같은 예제로 같은 이야기를 하고 있지만 또 각각 고유한 영역이 있기 때문에 둘다보는걸 추천한다.

어쩃든 시작해보자.


### 객체지향(역사 및 배경설명)
SRP 블로그 글 초반에 객체지향에서 유명한 키워드들인 ```관심사 분리```, ```결합도와 응집도``` 와 파르나스의 논문 하나를 소개하며 이들을 종합한 원칙으로 SRP가 탄생했다고 언급한다.  
방금 나온 키워드들은 모두 객체지향을 대표하는 키워드로 이를 통해 알 수 있는것은 SOLID 자체는 프로그래밍 전반의 대원칙이지만 객체지향으로부터 태동되었다는걸 알수있었다.

### 시스템을 모듈로 분해하는데 사용할 기준에 관한 논문
데이비드 L.파르나스라는 아져씨가 쓴 논문에대해서 짤막하게 설명한다.  
해당 글에서 등장한 논문의 내용을 요약해보면 시스템을 모듈로 분리시 **플로우 차트 기반으로 분해**하는것은 잘못된 접근이며 **설계가 어렵거나 변화 가능성이 있는 부분을 분리**하라고 설명한다.  
즉 변화의 가능성이 큰 부분을 분리해내서 다른 모듈로 부터 숨기고 격리시키는것을 목표로하라고 말한다.  

### SRP를 관통하는 한줄요약
이제 여기서 책과 블로그 글이 많이 다른데 책을 보는것을 추천한다.  
SRP는 네이밍을 잘못해서인지 제일 의도한 바와 다르게 전파된 원칙이라고 한다.  
실제로 나도 이번에 공부하기 이전까지는 하나의 객체(함수,객체, 모듈 등 그냥 단위를 나타내느것)가 하나의 일을 하는 법칙이라고 생각했다.

하지만 "하나의 함수가 하나의 일만 해야한다는 원칙"(구글링해도 원칙 이름이 안나온다)은 좀더 저수준의 리펙터링을 진행하는 용도이며 이는 SRP가 아니라고 명시되어있다.  

그래서 책에서는 다음과 같은 말로 SRP 를 설명하고 있다.  
>하나의 모듈은 하나의 액터(이해관계자)에 대해서만 책임져야 한다.

솔직히 SRP에 대한 설명을 다보고 난 다음에도 잘 와닿지 않았다.  
조금 풀어서 이야기 해보자면 코드에 변경을 가하는 요인이 되는 요소(사람 혹은 뭐 프로그램적 요소가 될수도)가 중복되게 되면 안된다는건데 

예시를 보면 이해가 좀 되는거 같으면서도 지금 글을 정리하는 시점에 설명할 방법이 떠오르지 않는걸 보면 이해하지 못한거같다.

그래서 결국에 예시를 보며 공감이 갔던 작은 원칙을 세울 수 있는 부분들이 있어 이부분에 집중해보려 한다.

-> 결국 클래스 분리 관련된 내용이다.

### 대략적인 예시설명
```
public class Employee {
  public Money calculatePay(); // CFO
  public void save(); // CTO
  public String reportHours(); // COO
}
```

다음과 같이 고용인 클래스를 보여준다.  
물론 잘못된 설계이지만 현실 세계의 근로자를 반영하고있어 충분히 누군가가 짤만한 클래스이다.(근로자에 관련된 행동들이 모여있다.)  

클래스 내부 함수를 설명하자면  

- calculatePay : CFO가 사용하는 돈 얼마줘야하나 계산하는 함수
- save : CTO가 사용하는 데이터 저장하는 함수
- reportHours : COO 가 사용하는 업무시간 계산하는 함수

근로자에 관한 행동들이 나열되어있다.  
이에 대해 SRP를 어떤식으로 어겼고 어떤부분을 고려해서 클래스를 설계해야하는지 알아보자


### 예시풀이 1 우발적 중복

Employee가 한 클래스내에 존재해서는 안되는 로직들이 모여있었고 이런 연유로 우발적 중복이 일어나 생기는 문제에 대해서 다룬다.

예시를 자세히 살펴보자

CFO 가 사용하는 calculatePay는 돈을 얼마나 줘야하는지 계산하는 함수이다.  
-> 여기서 해당 로직내 추가 근무시간을 계산하는 로직이 존재한다.  

COO가 사용하는 reportHours는 근무시간을 계산하는 함수이다.  
-> 여기서 또한 추가 근무를 계산하는 로직이 존재한다.  

한 클래스에 존재하는 각기 다른 두 함수에 같은 로직을 수행하는 구문이 있다 어떤 욕구가 드는가?  
당연히 함수로 분리해내어 중복을 제거하려고 할것이다.(이거 안하는게 더 비정상인이다.)  
여기서 이렇게 중복을 분리해내는것이 우발적으로 일어나는 사고라는것이다.  
분리된 함수명을 regularHours 라고 해보자

자 여기서 함수분리하여 추가근무 시간 계산을 하나의 함수를 사용하면서 어떤 문제가 생기는지 살펴보자.

CFO가 이끄는 집단에서 에서 도메인 룰이 바뀌어서 추가 근무 시간 계산로직이 변경 요청이 들어왔다.
개발자는 여기서 신나서 regularHours 함수를 뜯어 고칠거다.
하지만 이 도메인 룰이 COO가 관장하는 집단에서는 변경되지 않았고 이는 멀쩡히 돌아가고있던 reportHours 기능을 부셔버렸다.
심지어 애매하게 고장나서 바로 알아차리지 못하고 나중에 스노우 볼링이 구르는 슬픈 이야기를 책에서는 해준다.

물론 개발자가 유지보수하면서 함수를 고칠때 사용처를 다 확인해가면서 개발하긴 할것이다.(이걸 안할수 있나? 안하면 바로 킬각 잡힘)
하지만 언제 어디서나 휴먼에러는 나고 사용처가 너무 많아 놓칠때도 있지않는가?
이런 실수가 일어나는 구조 자체가 문제이다.

그렇다면 여기서 우리가 실질적으로 코드를 짤때 어떤 부분을 살펴봐야할지 내 견해를 정리해보았다.

#### 견해 1: 진정한 중복 / 가짜 중복을 판단할 수 있는 눈

regularHours는 가짜 중복을 나타내는 좋은 예시였다.
그렇다면 진정한 중복은 무엇일까? 예시에서는  regularHours가 각 부서별로 다른 룰을 가지기 때문에 문제가 생겼다.
하지만 사실 이런 시간계산법은 사내 공통적인 규칙일수도 있지 않는가? 만약 해당 룰이 변경될때 전사가 다 적용하는 룰이라면 이는 진정한 중복이며 같은 로직을 공유해도 된다.

방금 든 예시를 보면서 어떤생각이 들었는가?
같은 로직임에도 상황이 어떤가에 따라서 진정한 중복이 될수도 가짜 중복이 될수도 있다.
예언가가 아니고서야 이런 규칙들이 어떻게 변화할지 미래를 볼 수 없다. 내가 개발자이지 무당은 아니지 않는가?
사실상 이런 부분은 도메인 경험에서 우러나오는 예측정도이지 확실히 처음부터 완벽한 설계를 할 수는 없다고 생각한다.(이래서 도메인지식이 중요하구나)
이래서 초기 설계를 고쳐나갈수 있는 유연성과 리펙터링이 가능한 환경이 가장 중요하다고 생각한다.

어쨋든 이 부분에서 원칙을 정리해서 지켜나가며 설계를 해봐야하지 않겠는가?
사실 책은 거의 뭐 알잘딱하게 알아서 분리해봐 이정도 영역이라서 내가 그냥 나만의 규칙을 만들어봤다.

1. 중복에 너무 과민하지말자 (오히려 중복이 더 안전할 수 있다.)
2. 공통함수로 분리해낼때 사용처가 공통적인 변화를 가지는 단위인지 살펴본다.
3. 변화가 (함께)일어나는 단위별로 클래스를 분리하자
4. 도메인에 대해 잘살피고 서비스의 이해도를 높이자(알잘딱이지만 이게 진리이다.)

#### 견해 2: 가짜 중복을 막기위한 클래스 분리지점을 판단하는 눈

가짜 중복이 나타났을때 가장 좋은 해결 방법은 중복된 로직을 사용하는 책임 자체를 클래스 분리를 하는것이다.
기본적으로 객체지향 언어의 관점에서 클래스 단위에 중복이있으면 대부분 개발자들은 화가나서 분리하기 전까지 화를 참지 못한다.
이로인해 가짜중복이 쉽게 일어나기 때문에 이것들이 중복되어 보이지 않도록 하는 방법은 클래스 분리이다.

클래스만 분리되어있어도 중복에 대해 느끼는 불편함의 수준이 다를것이다. -> 이건 말로 설명할수 없다. 그냥 다들 알지 않는가?

그래서 객체가 들고있는 책임이 어떤 단위로 어떻게 분리되어야하는지 고심하고 어떤 로직을 함수화시켜서 공통화 시킬때는 애초에 같은 범주안에 드는 책임인지 고려해 볼 필요가 있다. 

#### 견해 3: 유틸코드화의 맹점

개발자 마다 스타일이 다 다르겠지만 어떤 동작에대해 유틸함수화 시켜서 사용하는 방법을 즐기는 개발자들을 많이 보았다.
하지만 이 또한 변화에 공통적으로 대응할 수 있는 공통화인가를 크게 고민해보아야한다.

SRP가 꼭 객체단위 이야기는 아니지 않는가? 객체보다 큰 단위에서 일어나는 공통화에도 주의를 기울일 필요가 있다고 생각한다.

결론적으로 Util 함수의 동작의 변화는 엄청 큰 파급효과를 불러올 수 있으니 신중해져야하고 이는 코드의 변경가능성(유연성)을 떨어트릴 수 있으니 항상 고민하고 공통화 시켜야 한다고 생각한다.



### 예시 풀이 2 병합

여러 액터가 하나의 클래스에 변경을 요청하면 코드 병합시 문제가 일어날 가능성이 크다는 이야기가 나온다.

예시로 한국캐시워크에는 서비스가 캐시닥,캐시딜,러닝크루,동네산책 등이 있다 각각 기획자분들이 존재하는데 해당 서비스 별로 분리없이 핵심로직들을 





 




## 참고자료
- [by Robert C. Martin (Uncle Bob) 블로그](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) / [해당 블로그 chatgpt 번역내용](https://chatgpt.com/share/6725d7ce-0298-8005-8352-b86b4a995f45)
- [solid 위키피디아](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))
- [퍼사드 패턴 설명](https://refactoring.guru/ko/design-patterns/facade)