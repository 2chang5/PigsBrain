# 단일 책임 원칙 Single Responsibility Principle
첫번쨰 원칙인 SRP 이다.  
전체적으로 모든 부분을 적으면 비효율적일 것 같아 글에서 중요하다고 느낀 키워드와 그 키워드에 대해 정리한 글을 쓰려한다.  
🐗 즉 멧돼지의 시선에서 본 SRP이다.  

블로그글과 책을 모두 읽고 작성한 내용으로 두개가 같은 예제로 같은 이야기를 하고 있지만 또 각각 고유한 영역이 있기 때문에 둘다보는걸 추천한다.

어쩃든 시작해보자.


### 객체지향(역사 및 배경설명)
SRP 블로그 글 초반에 객체지향에서 유명한 키워드들인 ```관심사 분리```, ```결합도와 응집도``` 와 파르나스의 논문 하나를 소개하며 이들을 종합한 원칙으로 SRP가 탄생했다고 언급한다.  
방금 나온 키워드들은 모두 객체지향을 대표하는 키워드로 이를 통해 알 수 있는것은 SOLID 자체는 프로그래밍 전반의 대원칙이지만 객체지향으로부터 태동되었다는걸 알수있었다.

### 시스템을 모듈로 분해하는데 사용할 기준에 관한 논문
데이비드 L.파르나스라는 아져씨가 쓴 논문에대해서 짤막하게 설명한다.  
해당 글에서 등장한 논문의 내용을 요약해보면 시스템을 모듈로 분리시 **플로우 차트 기반으로 분해**하는것은 잘못된 접근이며 **설계가 어렵거나 변화 가능성이 있는 부분을 분리**하라고 설명한다.  
즉 변화의 가능성이 큰 부분을 분리해내서 다른 모듈로 부터 숨기고 격리시키는것을 목표로하라고 말한다.  

### SRP를 관통하는 한줄요약
이제 여기서 책과 블로그 글이 많이 다른데 책을 보는것을 추천한다.  
SRP는 네이밍을 잘못해서인지 제일 의도한 바와 다르게 전파된 원칙이라고 한다.  
실제로 나도 이번에 공부하기 이전까지는 하나의 객체(함수,객체, 모듈 등 그냥 단위를 나타내느것)가 하나의 일을 하는 법칙이라고 생각했다.

하지만 "하나의 함수가 하나의 일만 해야한다는 원칙"(구글링해도 원칙 이름이 안나온다)은 좀더 저수준의 리펙터링을 진행하는 용도이며 이는 SRP가 아니라고 명시되어있다.  

그래서 책에서는 다음과 같은 말로 SRP 를 설명하고 있다.  
>하나의 모듈은 하나의 액터(이해관계자)에 대해서만 책임져야 한다.

솔직히 SRP에 대한 설명을 다보고 난 다음에도 잘 와닿지 않았다.  
조금 풀어서 이야기 해보자면 코드에 변경을 가하는 요인이 되는 요소(사람 혹은 뭐 프로그램적 요소가 될수도)가 중복되게 되면 안된다는건데 

예시를 보면 이해가 좀 되는거 같으면서도 지금 글을 정리하는 시점에 설명할 방법이 떠오르지 않는걸 보면 이해하지 못한거같다.

그래서 결국에 예시를 보며 공감이 갔던 작은 원칙을 세울 수 있는 부분들이 있어 이부분에 집중해보려 한다.

-> 결국 클래스 분리 관련된 내용이다.

### 대략적인 예시설명
```
public class Employee {
  public Money calculatePay(); // CFO
  public void save(); // CTO
  public String reportHours(); // COO
}
```

다음과 같이 고용인 클래스를 보여준다.  
물론 잘못된 설계이지만 현실 세계의 근로자를 반영하고있어 충분히 누군가가 짤만한 클래스이다.(근로자에 관련된 행동들이 모여있다.)  

클래스 내부 함수를 설명하자면  

- calculatePay : CFO가 사용하는 돈 얼마줘야하나 계산하는 함수
- save : CTO가 사용하는 데이터 저장하는 함수
- reportHours : COO 가 사용하는 업무시간 계산하는 함수

근로자에 관한 행동들이 나열되어있다.  
이에 대해 SRP를 어떤식으로 어겼고 어떤부분을 고려해서 클래스를 설계해야하는지 알아보자


### 예시풀이 1 우발적 중복

Employee가 한 클래스내에 존재해서는 안되는 로직들이 모여있었고 이런 연유로 우발적 중복이 일어나 생기는 문제에 대해서 다룬다.

예시를 자세히 살펴보자

CFO 가 사용하는 calculatePay는 돈을 얼마나 줘야하는지 계산하는 함수이다.  
-> 여기서 해당 로직내 추가 근무시간을 계산하는 로직이 존재한다.  

COO가 사용하는 reportHours는 근무시간을 계산하는 함수이다.  
-> 여기서 또한 추가 근무를 계산하는 로직이 존재한다.  

한 클래스에 존재하는 각기 다른 두 함수에 같은 로직을 수행하는 구문이 있다 어떤 욕구가 드는가?  
당연히 함수로 분리해내어 중복을 제거하려고 할것이다.(이거 안하는게 더 비정상인이다.)  
여기서 이렇게 중복을 분리해내는것이 우발적으로 일어나는 사고라는것이다.  
분리된 함수명을 regularHours 라고 해보자

자 여기서 함수분리하여 추가근무 시간 계산을 하나의 함수를 사용하면서 어떤 문제가 생기는지 살펴보자.

CFO가 이끄는 집단에서 에서 도메인 룰이 바뀌어서 추가 근무 시간 계산로직이 변경 요청이 들어왔다.
개발자는 여기서 신나서 regularHours 함수를 뜯어 고칠거다.
하지만 이 도메인 룰이 COO가 관장하는 집단에서는 변경되지 않았고 이는 멀쩡히 돌아가고있던 reportHours 기능을 부셔버렸다.
심지어 애매하게 고장나서 바로 알아차리지 못하고 나중에 스노우 볼링이 구르는 슬픈 이야기를 책에서는 해준다.

물론 개발자가 유지보수하면서 함수를 고칠때 사용처를 다 확인해가면서 개발하긴 할것이다.(이걸 안할수 있나? 안하면 바로 킬각 잡힘)
하지만 언제 어디서나 휴먼에러는 나고 사용처가 너무 많아 놓칠때도 있지않는가?
이런 실수가 일어나는 구조 자체가 문제이다.

그렇다면 여기서 우리가 실질적으로 코드를 짤떄 어떤 부분을 살펴봐야할지 내 견해를 정리해보았다.




-유틸 코드 막뺴도됨?
-진정한 중복 가짜중복을 바라보는눈
-이런것들을 원초적으로 막기위한 클래스 분리지점을 바라보는 눈



 




## 참고자료
- [by Robert C. Martin (Uncle Bob) 블로그](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) / [해당 블로그 chatgpt 번역내용](https://chatgpt.com/share/6725d7ce-0298-8005-8352-b86b4a995f45)
- [solid 위키피디아](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))
- [퍼사드 패턴 설명](https://refactoring.guru/ko/design-patterns/facade)