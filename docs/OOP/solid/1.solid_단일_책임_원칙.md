# 단일 책임 원칙 Single Responsibility Principle
첫번쨰 원칙인 SRP 이다.  
전체적으로 모든 부분을 적으면 비효율적일 것 같아 글에서 중요하다고 느낀 키워드와 그 키워드에 대해 정리한 글을 쓰려한다.  
🐗 즉 멧돼지의 시선에서 본 SRP이다.  

블로그글과 책을 모두 읽고 작성한 내용으로 두개가 같은 예제로 같은 이야기를 하고 있지만 또 각각 고유한 영역이 있기 때문에 둘다보는걸 추천한다.

어쩃든 시작해보자.


### 객체지향(역사 및 배경설명)
SRP 블로그 글 초반에 객체지향에서 유명한 키워드들인 ```관심사 분리```, ```결합도와 응집도``` 와 파르나스의 논문 하나를 소개하며 이들을 종합한 원칙으로 SRP가 탄생했다고 언급한다.  
방금 나온 키워드들은 모두 객체지향을 대표하는 키워드로 이를 통해 알 수 있는것은 SOLID 자체는 프로그래밍 전반의 대원칙이지만 객체지향으로부터 태동되었다는걸 알수있었다.

### 시스템을 모듈로 분해하는데 사용할 기준에 관한 논문
데이비드 L.파르나스라는 아져씨가 쓴 논문에대해서 짤막하게 설명한다.  
해당 글에서 등장한 논문의 내용을 요약해보면 시스템을 모듈로 분리시 **플로우 차트 기반으로 분해**하는것은 잘못된 접근이며 **설계가 어렵거나 변화 가능성이 있는 부분을 분리**하라고 설명한다.  
즉 변화의 가능성이 큰 부분을 분리해내서 다른 모듈로 부터 숨기고 격리시키는것을 목표로하라고 말한다.  

### SRP를 관통하는 한줄요약
이제 여기서 책과 블로그 글이 많이 다른데 책을 보는것을 추천한다.  
SRP는 네이밍을 잘못해서인지 제일 의도한 바와 다르게 전파된 원칙이라고 한다.  
실제로 나도 이번에 공부하기 이전까지는 하나의 객체(함수,객체, 모듈 등 그냥 단위를 나타내느것)가 하나의 일을 하는 법칙이라고 생각했다.

하지만 "하나의 함수가 하나의 일만 해야한다는 원칙"(구글링해도 원칙 이름이 안나온다)은 좀더 저수준의 리펙터링을 진행하는 용도이며 이는 SRP가 아니라고 명시되어있다.  

그래서 책에서는 다음과 같은 말로 SRP 를 설명하고 있다.  
>하나의 모듈은 하나의 액터(이해관계자)에 대해서만 책임져야 한다.

솔직히 SRP에 대한 설명을 다보고 난 다음에도 잘 와닿지 않았다.  
조금 풀어서 이야기 해보자면 코드에 변경을 가하는 요인이 되는 요소(사람 혹은 뭐 프로그램적 요소가 될수도)가 중복되게 되면 안된다는건데 

예시를 보면 이해가 좀 되는거 같으면서도 지금 글을 정리하는 시점에 설명할 방법이 떠오르지 않는걸 보면 이해하지 못한거같다.

그래서 결국에 예시를 보며 공감이 갔던 작은 원칙을 세울 수 있는 부분들이 있어 이부분에 집중해보려 한다.

-> 결국 클래스 분리 관련된 내용이다.

### 대략적인 예시설명
```
public class Employee {
  public Money calculatePay(); // CFO
  public void save(); // CTO
  public String reportHours(); // COO
}
```

다음과 같이 고용인 클래스를 보여준다.

물론 잘못된 설계이지만 현실 세계의 근로자를 반영하고있어 충분히 누군가가 짤만한 클래스이다.

클래스 내부 함수를 설명하자면

- calculatePay : CFO가 사용하는 돈 얼마줘야하나 계산하는 함수
- save : CTO가 사용하는 데이터 저장하는 함수
- reportHours : COO 가 사용하는 업무시간 계산하는 함수

근로자에 관한 행동들이 나열되어있다.

이에대해 SRP를 어떤식으로 어겼고 어떤부분을 고려해서 클래스를 설계해야하는지 알아보자



### 예시풀이 1 우발적 중복

Employee가 한 클래스내에 존재해서는 안되는 로직들이 모여있었고 이런 연유로 우발적 중복이 일어나 생기는 문제에 대해서 다룬다.

예시를 자세히 살펴보자

CFO 가 사용하는 calculatePay 는 돈을 얼마나 줘야하는지 계산해야하므로 내부적으로 시간을 계산하는 함수인 regularHours를 사용하며

COO가 사용하는 reportHours 또한 시간계산이 필요하여 regularHours라는 함수를 공유하도록 설계 되어있다고 가정해보자.

한 클래스 내 같은 기능을 하는 코드가 중복되어있으면 함수분리를 당연하게 하게 될것이다. (이걸 안하는놈이 더 이상하게 보일것이다.)

하지만 이게 잘못된 설계를 나타내는 증거이다.



 




## 참고자료
- [by Robert C. Martin (Uncle Bob) 블로그](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html) / [해당 블로그 chatgpt 번역내용](https://chatgpt.com/share/6725d7ce-0298-8005-8352-b86b4a995f45)
- [solid 위키피디아](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))
- [퍼사드 패턴 설명](https://refactoring.guru/ko/design-patterns/facade)